<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>4 Customizing Resourceful Routes</title>
<link rel="stylesheet" type="text/css" href="/home/rails/v6.0.6.1/guides/output/kindle/stylesheets/kindle.css">
</head>
<body>
<h3 id="customizing-resourceful-routes"><a class="anchorlink" href="#customizing-resourceful-routes">4 Customizing Resourceful Routes</a></h3>
<p>While the default routes and helpers generated by <code>resources :articles</code> will usually serve you well, you may want to customize them in some way. Rails allows you to customize virtually any generic part of the resourceful helpers.</p>

<h4 id="specifying-a-controller-to-use"><a class="anchorlink" href="#specifying-a-controller-to-use">4.1 Specifying a Controller to Use</a></h4>

<p>The <code>:controller</code> option lets you explicitly specify a controller to use for the resource. For example:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :photos, controller: 'images'

</pre>
</div>
<p>will recognize incoming paths beginning with <code>/photos</code> but route to the <code>Images</code> controller:</p>
<table>
<thead>
<tr>
<th>HTTP Verb</th>
<th>Path</th>
<th>Controller#Action</th>
<th>Named Route Helper</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/photos</td>
<td>images#index</td>
<td>photos_path</td>
</tr>
<tr>
<td>GET</td>
<td>/photos/new</td>
<td>images#new</td>
<td>new_photo_path</td>
</tr>
<tr>
<td>POST</td>
<td>/photos</td>
<td>images#create</td>
<td>photos_path</td>
</tr>
<tr>
<td>GET</td>
<td>/photos/:id</td>
<td>images#show</td>
<td>photo_path(:id)</td>
</tr>
<tr>
<td>GET</td>
<td>/photos/:id/edit</td>
<td>images#edit</td>
<td>edit_photo_path(:id)</td>
</tr>
<tr>
<td>PATCH/PUT</td>
<td>/photos/:id</td>
<td>images#update</td>
<td>photo_path(:id)</td>
</tr>
<tr>
<td>DELETE</td>
<td>/photos/:id</td>
<td>images#destroy</td>
<td>photo_path(:id)</td>
</tr>
</tbody>
</table>
<div class="note"><p>Use <code>photos_path</code>, <code>new_photo_path</code>, etc. to generate paths for this resource.</p></div>

<p>For namespaced controllers you can use the directory notation. For example:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :user_permissions, controller: 'admin/user_permissions'

</pre>
</div>
<p>This will route to the <code>Admin::UserPermissions</code> controller.</p>

<div class="note"><p>Only the directory notation is supported. Specifying the
controller with Ruby constant notation (eg. <code>controller: 'Admin::UserPermissions'</code>)
can lead to routing problems and results in
a warning.</p></div>

<h4 id="specifying-constraints"><a class="anchorlink" href="#specifying-constraints">4.2 Specifying Constraints</a></h4>

<p>You can use the <code>:constraints</code> option to specify a required format on the implicit <code>id</code>. For example:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :photos, constraints: { id: /[A-Z][A-Z][0-9]+/ }

</pre>
</div>
<p>This declaration constrains the <code>:id</code> parameter to match the supplied regular expression. So, in this case, the router would no longer match <code>/photos/1</code> to this route. Instead, <code>/photos/RR27</code> would match.</p>

<p>You can specify a single constraint to apply to a number of routes by using the block form:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
constraints(id: /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
end

</pre>
</div>
<div class="note"><p>Of course, you can use the more advanced constraints available in non-resourceful routes in this context.</p></div>

<div class="info"><p>By default the <code>:id</code> parameter doesn't accept dots - this is because the dot is used as a separator for formatted routes. If you need to use a dot within an <code>:id</code> add a constraint which overrides this - for example <code>id: /[^\/]+/</code> allows anything except a slash.</p></div>

<h4 id="overriding-the-named-route-helpers"><a class="anchorlink" href="#overriding-the-named-route-helpers">4.3 Overriding the Named Route Helpers</a></h4>

<p>The <code>:as</code> option lets you override the normal naming for the named route helpers. For example:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :photos, as: 'images'

</pre>
</div>
<p>will recognize incoming paths beginning with <code>/photos</code> and route the requests to <code>PhotosController</code>, but use the value of the <code>:as</code> option to name the helpers.</p>
<table>
<thead>
<tr>
<th>HTTP Verb</th>
<th>Path</th>
<th>Controller#Action</th>
<th>Named Route Helper</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/photos</td>
<td>photos#index</td>
<td>images_path</td>
</tr>
<tr>
<td>GET</td>
<td>/photos/new</td>
<td>photos#new</td>
<td>new_image_path</td>
</tr>
<tr>
<td>POST</td>
<td>/photos</td>
<td>photos#create</td>
<td>images_path</td>
</tr>
<tr>
<td>GET</td>
<td>/photos/:id</td>
<td>photos#show</td>
<td>image_path(:id)</td>
</tr>
<tr>
<td>GET</td>
<td>/photos/:id/edit</td>
<td>photos#edit</td>
<td>edit_image_path(:id)</td>
</tr>
<tr>
<td>PATCH/PUT</td>
<td>/photos/:id</td>
<td>photos#update</td>
<td>image_path(:id)</td>
</tr>
<tr>
<td>DELETE</td>
<td>/photos/:id</td>
<td>photos#destroy</td>
<td>image_path(:id)</td>
</tr>
</tbody>
</table>
<h4 id="overriding-the-new-and-edit-segments"><a class="anchorlink" href="#overriding-the-new-and-edit-segments">4.4 Overriding the <code>new</code> and <code>edit</code> Segments</a></h4>

<p>The <code>:path_names</code> option lets you override the automatically-generated <code>new</code> and <code>edit</code> segments in paths:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :photos, path_names: { new: 'make', edit: 'change' }

</pre>
</div>
<p>This would cause the routing to recognize paths such as:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
/photos/make
/photos/1/change

</pre>
</div>
<div class="note"><p>The actual action names aren't changed by this option. The two paths shown would still route to the <code>new</code> and <code>edit</code> actions.</p></div>

<div class="info"><p>If you find yourself wanting to change this option uniformly for all of your routes, you can use a scope.</p></div>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
scope path_names: { new: 'make' } do
  # rest of your routes
end

</pre>
</div>
<h4 id="prefixing-the-named-route-helpers"><a class="anchorlink" href="#prefixing-the-named-route-helpers">4.5 Prefixing the Named Route Helpers</a></h4>

<p>You can use the <code>:as</code> option to prefix the named route helpers that Rails generates for a route. Use this option to prevent name collisions between routes using a path scope. For example:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
scope 'admin' do
  resources :photos, as: 'admin_photos'
end

resources :photos

</pre>
</div>
<p>This will provide route helpers such as <code>admin_photos_path</code>, <code>new_admin_photo_path</code>, etc.</p>

<p>To prefix a group of route helpers, use <code>:as</code> with <code>scope</code>:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
scope 'admin', as: 'admin' do
  resources :photos, :accounts
end

resources :photos, :accounts

</pre>
</div>
<p>This will generate routes such as <code>admin_photos_path</code> and <code>admin_accounts_path</code> which map to <code>/admin/photos</code> and <code>/admin/accounts</code> respectively.</p>

<div class="note"><p>The <code>namespace</code> scope will automatically add <code>:as</code> as well as <code>:module</code> and <code>:path</code> prefixes.</p></div>

<p>You can prefix routes with a named parameter also:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
scope ':username' do
  resources :articles
end

</pre>
</div>
<p>This will provide you with URLs such as <code>/bob/articles/1</code> and will allow you to reference the <code>username</code> part of the path as <code>params[:username]</code> in controllers, helpers, and views.</p>

<h4 id="restricting-the-routes-created"><a class="anchorlink" href="#restricting-the-routes-created">4.6 Restricting the Routes Created</a></h4>

<p>By default, Rails creates routes for the seven default actions (<code>index</code>, <code>show</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code>, and <code>destroy</code>) for every RESTful route in your application. You can use the <code>:only</code> and <code>:except</code> options to fine-tune this behavior. The <code>:only</code> option tells Rails to create only the specified routes:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :photos, only: [:index, :show]

</pre>
</div>
<p>Now, a <code>GET</code> request to <code>/photos</code> would succeed, but a <code>POST</code> request to <code>/photos</code> (which would ordinarily be routed to the <code>create</code> action) will fail.</p>

<p>The <code>:except</code> option specifies a route or list of routes that Rails should <em>not</em> create:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :photos, except: :destroy

</pre>
</div>
<p>In this case, Rails will create all of the normal routes except the route for <code>destroy</code> (a <code>DELETE</code> request to <code>/photos/:id</code>).</p>

<div class="info"><p>If your application has many RESTful routes, using <code>:only</code> and <code>:except</code> to generate only the routes that you actually need can cut down on memory use and speed up the routing process.</p></div>

<h4 id="translated-paths"><a class="anchorlink" href="#translated-paths">4.7 Translated Paths</a></h4>

<p>Using <code>scope</code>, we can alter path names generated by <code>resources</code>:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
scope(path_names: { new: 'neu', edit: 'bearbeiten' }) do
  resources :categories, path: 'kategorien'
end

</pre>
</div>
<p>Rails now creates routes to the <code>CategoriesController</code>.</p>
<table>
<thead>
<tr>
<th>HTTP Verb</th>
<th>Path</th>
<th>Controller#Action</th>
<th>Named Route Helper</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/kategorien</td>
<td>categories#index</td>
<td>categories_path</td>
</tr>
<tr>
<td>GET</td>
<td>/kategorien/neu</td>
<td>categories#new</td>
<td>new_category_path</td>
</tr>
<tr>
<td>POST</td>
<td>/kategorien</td>
<td>categories#create</td>
<td>categories_path</td>
</tr>
<tr>
<td>GET</td>
<td>/kategorien/:id</td>
<td>categories#show</td>
<td>category_path(:id)</td>
</tr>
<tr>
<td>GET</td>
<td>/kategorien/:id/bearbeiten</td>
<td>categories#edit</td>
<td>edit_category_path(:id)</td>
</tr>
<tr>
<td>PATCH/PUT</td>
<td>/kategorien/:id</td>
<td>categories#update</td>
<td>category_path(:id)</td>
</tr>
<tr>
<td>DELETE</td>
<td>/kategorien/:id</td>
<td>categories#destroy</td>
<td>category_path(:id)</td>
</tr>
</tbody>
</table>
<h4 id="overriding-the-singular-form"><a class="anchorlink" href="#overriding-the-singular-form">4.8 Overriding the Singular Form</a></h4>

<p>If you want to define the singular form of a resource, you should add additional rules to the <code>Inflector</code>:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'tooth', 'teeth'
end

</pre>
</div>
<h4 id="using-as-in-nested-resources"><a class="anchorlink" href="#using-as-in-nested-resources">4.9 Using <code>:as</code> in Nested Resources</a></h4>

<p>The <code>:as</code> option overrides the automatically-generated name for the resource in nested route helpers. For example:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :magazines do
  resources :ads, as: 'periodical_ads'
end

</pre>
</div>
<p>This will create routing helpers such as <code>magazine_periodical_ads_url</code> and <code>edit_magazine_periodical_ad_path</code>.</p>

<h4 id="overriding-named-route-parameters"><a class="anchorlink" href="#overriding-named-route-parameters">4.10 Overriding Named Route Parameters</a></h4>

<p>The <code>:param</code> option overrides the default resource identifier <code>:id</code> (name of
the <a href="routing.html#dynamic-segments">dynamic segment</a> used to generate the
routes). You can access that segment from your controller using
<code>params[&lt;:param&gt;]</code>.</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
resources :videos, param: :identifier

</pre>
</div>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
    videos GET  /videos(.:format)                  videos#index
           POST /videos(.:format)                  videos#create
 new_video GET  /videos/new(.:format)              videos#new
edit_video GET  /videos/:identifier/edit(.:format) videos#edit

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Video.find_by(identifier: params[:identifier])

</pre>
</div>
<p>You can override <code>ActiveRecord::Base#to_param</code> of a related model to construct
a URL:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Video &lt; ApplicationRecord
  def to_param
    identifier
  end
end

video = Video.find_by(identifier: "Roman-Holiday")
edit_video_path(video) # =&gt; "/videos/Roman-Holiday/edit"

</pre>
</div>
</body>
</html>

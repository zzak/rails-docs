<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>5 Getting Up and Running</title>
<link rel="stylesheet" type="text/css" href="/home/rails/v6.0.6.1/guides/output/kindle/stylesheets/kindle.css">
</head>
<body>
<h3 id="getting-up-and-running"><a class="anchorlink" href="#getting-up-and-running">5 Getting Up and Running</a></h3>
<p>Now that you've seen how to create a controller, an action, and a view, let's
create something with a bit more substance.</p>

<p>In the Blog application, you will now create a new <em>resource</em>. A resource is the
term used for a collection of similar objects, such as articles, people, or
animals.
You can create, read, update, and destroy items for a resource and these
operations are referred to as <em>CRUD</em> operations.</p>

<p>Rails provides a <code>resources</code> method which can be used to declare a standard REST
resource. You need to add the <em>article resource</em> to the
<code>config/routes.rb</code> so the file will look as follows:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Rails.application.routes.draw do
  get 'welcome/index'

  resources :articles

  root 'welcome#index'
end

</pre>
</div>
<p>If you run <code>rails routes</code>, you'll see that it has defined routes for all the
standard RESTful actions.  The meaning of the prefix column (and other columns)
will be seen later, but for now notice that Rails has inferred the
singular form <code>article</code> and makes meaningful use of the distinction.</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails routes
       Prefix Verb   URI Pattern                  Controller#Action
welcome_index GET    /welcome/index(.:format)     welcome#index
     articles GET    /articles(.:format)          articles#index
              POST   /articles(.:format)          articles#create
  new_article GET    /articles/new(.:format)      articles#new
 edit_article GET    /articles/:id/edit(.:format) articles#edit
      article GET    /articles/:id(.:format)      articles#show
              PATCH  /articles/:id(.:format)      articles#update
              PUT    /articles/:id(.:format)      articles#update
              DELETE /articles/:id(.:format)      articles#destroy
         root GET    /                            welcome#index

</pre>
</div>
<p>In the next section, you will add the ability to create new articles in your
application and be able to view them. This is the "C" and the "R" from CRUD:
create and read. The form for doing this will look like this:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/new_article.png" alt="The new article form"></p>

<p>It will look a little basic for now, but that's ok. We'll look at improving the
styling for it afterwards.</p>

<h4 id="laying-down-the-groundwork"><a class="anchorlink" href="#laying-down-the-groundwork">5.1 Laying down the groundwork</a></h4>

<p>Firstly, you need a place within the application to create a new article. A
great place for that would be at <code>/articles/new</code>. With the route already
defined, requests can now be made to <code>/articles/new</code> in the application.
Navigate to <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> and you'll see a routing
error:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/routing_error_no_controller.png" alt="Another routing error, uninitialized constant ArticlesController"></p>

<p>This error occurs because the route needs to have a controller defined in order
to serve the request. The solution to this particular problem is simple: create
a controller called <code>ArticlesController</code>. You can do this by running this
command:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate controller Articles

</pre>
</div>
<p>If you open up the newly generated <code>app/controllers/articles_controller.rb</code>
you'll see a fairly empty controller:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
end

</pre>
</div>
<p>A controller is simply a class that is defined to inherit from
<code>ApplicationController</code>.
It's inside this class that you'll define methods that will become the actions
for this controller. These actions will perform CRUD operations on the articles
within our system.</p>

<div class="note"><p>There are <code>public</code>, <code>private</code> and <code>protected</code> methods in Ruby,
but only <code>public</code> methods can be actions for controllers.
For more details check out <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">Programming Ruby</a>.</p></div>

<p>If you refresh <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> now, you'll get a new error:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/unknown_action_new_for_articles.png" alt="Unknown action new for ArticlesController!"></p>

<p>This error indicates that Rails cannot find the <code>new</code> action inside the
<code>ArticlesController</code> that you just generated. This is because when controllers
are generated in Rails they are empty by default, unless you tell it
your desired actions during the generation process.</p>

<p>To manually define an action inside a controller, all you need to do is to
define a new method inside the controller. Open
<code>app/controllers/articles_controller.rb</code> and inside the <code>ArticlesController</code>
class, define the <code>new</code> method so that your controller now looks like this:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def new
  end
end

</pre>
</div>
<p>With the <code>new</code> method defined in <code>ArticlesController</code>, if you refresh
<a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> you'll see another error:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/template_is_missing_articles_new.png" alt="Template is missing for articles/new"></p>

<p>You're getting this error now because Rails expects plain actions like this one
to have views associated with them to display their information. With no view
available, Rails will raise an exception.</p>

<p>Let's look at the full error message again:</p>
<blockquote>
<p>ArticlesController#new is missing a template for request formats: text/html</p>
<p>NOTE!
Unless told otherwise, Rails expects an action to render a template with the same name, contained in a folder named after its controller. If this controller is an API responding with 204 (No Content), which does not require a template, then this error will occur when trying to access it via browser, since we expect an HTML template to be rendered for such requests. If that's the case, carry on.</p>
</blockquote>
<p>The message identifies which template is missing. In this case, it's the
<code>articles/new</code> template. Rails will first look for this template. If not found,
then it will attempt to load a template called <code>application/new</code>, because the
<code>ArticlesController</code> inherits from <code>ApplicationController</code>.</p>

<p>Next the message contains <code>request.formats</code> which specifies the format of
template to be served in response. It is set to <code>text/html</code> as we requested
this page via browser, so Rails is looking for an HTML template.</p>

<p>The simplest template that would work in this case would be one located at
<code>app/views/articles/new.html.erb</code>. The extension of this file name is important:
the first extension is the <em>format</em> of the template, and the second extension
is the <em>handler</em> that will be used to render the template. Rails is attempting
to find a template called <code>articles/new</code> within <code>app/views</code> for the
application. The format for this template can only be <code>html</code> and the default
handler for HTML is <code>erb</code>. Rails uses other handlers for other formats.
<code>builder</code> handler is used to build XML templates and <code>coffee</code> handler uses
CoffeeScript to build JavaScript templates. Since you want to create a new
HTML form, you will be using the <code>ERB</code> language which is designed to embed Ruby
in HTML.</p>

<p>Therefore the file should be called <code>articles/new.html.erb</code> and needs to be
located inside the <code>app/views</code> directory of the application.</p>

<p>Go ahead now and create a new file at <code>app/views/articles/new.html.erb</code> and
write this content in it:</p>

<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;h1&gt;New Article&lt;/h1&gt;

</pre>
</div>
<p>When you refresh <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> you'll now see that the
page has a title. The route, controller, action, and view are now working
harmoniously! It's time to create the form for a new article.</p>

<h4 id="the-first-form"><a class="anchorlink" href="#the-first-form">5.2 The first form</a></h4>

<p>To create a form within this template, you will use a <em>form
builder</em>. The primary form builder for Rails is provided by a helper
method called <code>form_with</code>. To use this method, add this code into
<code>app/views/articles/new.html.erb</code>:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, local: true do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;
&lt;% end %&gt;

</pre>
</div>
<p>If you refresh the page now, you'll see the exact same form from our example above.
Building forms in Rails is really just that easy!</p>

<p>When you call <code>form_with</code>, you pass it an identifying scope for this
form. In this case, it's the symbol <code>:article</code>. This tells the <code>form_with</code>
helper what this form is for. Inside the block for this method, the
<code>FormBuilder</code> object - represented by <code>form</code> - is used to build two labels and two
text fields, one each for the title and text of an article. Finally, a call to
<code>submit</code> on the <code>form</code> object will create a submit button for the form.</p>

<p>There's one problem with this form though. If you inspect the HTML that is
generated, by viewing the source of the page, you will see that the <code>action</code>
attribute for the form is pointing at <code>/articles/new</code>. This is a problem because
this route goes to the very page that you're on right at the moment, and that
route should only be used to display the form for a new article.</p>

<p>The form needs to use a different URL in order to go somewhere else.
This can be done quite simply with the <code>:url</code> option of <code>form_with</code>.
Typically in Rails, the action that is used for new form submissions
like this is called "create", and so the form should be pointed to that action.</p>

<p>Edit the <code>form_with</code> line inside <code>app/views/articles/new.html.erb</code> to look like
this:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, url: articles_path, local: true do |form| %&gt;

</pre>
</div>
<p>In this example, the <code>articles_path</code> helper is passed to the <code>:url</code> option.
To see what Rails will do with this, we look back at the output of
<code>rails routes</code>:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails routes
      Prefix Verb   URI Pattern                  Controller#Action
welcome_index GET    /welcome/index(.:format)     welcome#index
     articles GET    /articles(.:format)          articles#index
              POST   /articles(.:format)          articles#create
  new_article GET    /articles/new(.:format)      articles#new
 edit_article GET    /articles/:id/edit(.:format) articles#edit
      article GET    /articles/:id(.:format)      articles#show
              PATCH  /articles/:id(.:format)      articles#update
              PUT    /articles/:id(.:format)      articles#update
              DELETE /articles/:id(.:format)      articles#destroy
         root GET    /                            welcome#index

</pre>
</div>
<p>The <code>articles_path</code> helper tells Rails to point the form to the URI Pattern
associated with the <code>articles</code> prefix; and the form will (by default) send a
<code>POST</code> request to that route. This is associated with the <code>create</code> action of
the current controller, the <code>ArticlesController</code>.</p>

<p>With the form and its associated route defined, you will be able to fill in the
form and then click the submit button to begin the process of creating a new
article, so go ahead and do that. When you submit the form, you should see a
familiar error:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/unknown_action_create_for_articles.png" alt="Unknown action create for ArticlesController"></p>

<p>You now need to create the <code>create</code> action within the <code>ArticlesController</code> for
this to work.</p>

<div class="note"><p>By default <code>form_with</code> submits forms using Ajax thereby skipping full page
redirects. To make this guide easier to get into we've disabled that with
<code>local: true</code> for now.</p></div>

<h4 id="creating-articles"><a class="anchorlink" href="#creating-articles">5.3 Creating articles</a></h4>

<p>To make the "Unknown action" go away, you can define a <code>create</code> action within
the <code>ArticlesController</code> class in <code>app/controllers/articles_controller.rb</code>,
underneath the <code>new</code> action, as shown:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def new
  end

  def create
  end
end

</pre>
</div>
<p>If you re-submit the form now, you may not see any change on the page. Don't worry!
This is because Rails by default returns <code>204 No Content</code> response for an action if
we don't specify what the response should be. We just added the <code>create</code> action
but didn't specify anything about how the response should be. In this case, the
<code>create</code> action should save our new article to the database.</p>

<p>When a form is submitted, the fields of the form are sent to Rails as
<em>parameters</em>. These parameters can then be referenced inside the controller
actions, typically to perform a particular task. To see what these parameters
look like, change the <code>create</code> action to this:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  render plain: params[:article].inspect
end

</pre>
</div>
<p>The <code>render</code> method here is taking a very simple hash with a key of <code>:plain</code> and
value of <code>params[:article].inspect</code>. The <code>params</code> method is the object which
represents the parameters (or fields) coming in from the form. The <code>params</code>
method returns an <code>ActionController::Parameters</code> object, which
allows you to access the keys of the hash using either strings or symbols. In
this situation, the only parameters that matter are the ones from the form.</p>

<div class="info"><p>Ensure you have a firm grasp of the <code>params</code> method, as you'll use it fairly regularly. Let's consider an example URL: <strong><a href="http://www.example.com/?username=dhh&amp;email=dhh@email.com">http://www.example.com/?username=dhh&amp;email=dhh@email.com</a></strong>. In this URL, <code>params[:username]</code> would equal "dhh" and <code>params[:email]</code> would equal "<a href="mailto:dhh@email.com">dhh@email.com</a>".</p></div>

<p>If you re-submit the form one more time, you'll see something that looks like the following:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
&lt;ActionController::Parameters {"title"=&gt;"First Article!", "text"=&gt;"This is my first article."} permitted: false&gt;

</pre>
</div>
<p>This action is now displaying the parameters for the article that are coming in
from the form. However, this isn't really all that helpful. Yes, you can see the
parameters but nothing in particular is being done with them.</p>

<h4 id="creating-the-article-model"><a class="anchorlink" href="#creating-the-article-model">5.4 Creating the Article model</a></h4>

<p>Models in Rails use a singular name, and their corresponding database tables
use a plural name. Rails provides a generator for creating models, which most
Rails developers tend to use when creating new models. To create the new model,
run this command in your terminal:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails generate model Article title:string text:text

</pre>
</div>
<p>With that command we told Rails that we want an <code>Article</code> model, together
with a <em>title</em> attribute of type string, and a <em>text</em> attribute
of type text. Those attributes are automatically added to the <code>articles</code>
table in the database and mapped to the <code>Article</code> model.</p>

<p>Rails responded by creating a bunch of files. For now, we're only interested
in <code>app/models/article.rb</code> and <code>db/migrate/20140120191729_create_articles.rb</code>
(your name could be a bit different). The latter is responsible for creating
the database structure, which is what we'll look at next.</p>

<div class="info"><p>Active Record is smart enough to automatically map column names to model
attributes, which means you don't have to declare attributes inside Rails
models, as that will be done automatically by Active Record.</p></div>

<h4 id="running-a-migration"><a class="anchorlink" href="#running-a-migration">5.5 Running a Migration</a></h4>

<p>As we've just seen, <code>rails generate model</code> created a <em>database migration</em> file
inside the <code>db/migrate</code> directory. Migrations are Ruby classes that are
designed to make it simple to create and modify database tables. Rails uses
rake commands to run migrations, and it's possible to undo a migration after
it's been applied to your database. Migration filenames include a timestamp to
ensure that they're processed in the order that they were created.</p>

<p>If you look in the <code>db/migrate/YYYYMMDDHHMMSS_create_articles.rb</code> file
(remember, yours will have a slightly different name), here's what you'll find:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateArticles &lt; ActiveRecord::Migration[6.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end

</pre>
</div>
<p>The above migration creates a method named <code>change</code> which will be called when
you run this migration. The action defined in this method is also reversible,
which means Rails knows how to reverse the change made by this migration,
in case you want to reverse it later. When you run this migration it will create
an <code>articles</code> table with one string column and a text column. It also creates
two timestamp fields to allow Rails to track article creation and update times.</p>

<div class="info"><p>For more information about migrations, refer to <a href="active_record_migrations.html">Active Record Migrations</a>.</p></div>

<p>At this point, you can use a rails command to run the migration:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails db:migrate

</pre>
</div>
<p>Rails will execute this migration command and tell you it created the Articles
table.</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
==  CreateArticles: migrating ==================================================
-- create_table(:articles)
   -&gt; 0.0019s
==  CreateArticles: migrated (0.0020s) =========================================

</pre>
</div>
<div class="note"><p>Because you're working in the development environment by default, this
command will apply to the database defined in the <code>development</code> section of your
<code>config/database.yml</code> file. If you would like to execute migrations in another
environment, for instance in production, you must explicitly pass it when
invoking the command: <code>rails db:migrate RAILS_ENV=production</code>.</p></div>

<h4 id="saving-data-in-the-controller"><a class="anchorlink" href="#saving-data-in-the-controller">5.6 Saving data in the controller</a></h4>

<p>Back in <code>ArticlesController</code>, we need to change the <code>create</code> action
to use the new <code>Article</code> model to save the data in the database.
Open <code>app/controllers/articles_controller.rb</code> and change the <code>create</code> action to
look like this:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @article = Article.new(params[:article])

  @article.save
  redirect_to @article
end

</pre>
</div>
<p>Here's what's going on: every Rails model can be initialized with its
respective attributes, which are automatically mapped to the respective
database columns. In the first line we do just that (remember that
<code>params[:article]</code> contains the attributes we're interested in). Then,
<code>@article.save</code> is responsible for saving the model in the database. Finally,
we redirect the user to the <code>show</code> action, which we'll define later.</p>

<div class="info"><p>You might be wondering why the <code>A</code> in <code>Article.new</code> is capitalized above, whereas most other references to articles in this guide have used lowercase. In this context, we are referring to the class named <code>Article</code> that is defined in <code>app/models/article.rb</code>. Class names in Ruby must begin with a capital letter.</p></div>

<div class="info"><p>As we'll see later, <code>@article.save</code> returns a boolean indicating whether
the article was saved or not.</p></div>

<p>If you now go to <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> you'll <em>almost</em> be able
to create an article. Try it! You should get an error that looks like this:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/forbidden_attributes_for_new_article.png" alt="Forbidden attributes for new article"></p>

<p>Rails has several security features that help you write secure applications,
and you're running into one of them now. This one is called <a href="action_controller_overview.html#strong-parameters">strong parameters</a>,
which requires us to tell Rails exactly which parameters are allowed into our
controller actions.</p>

<p>Why do you have to bother? The ability to grab and automatically assign all
controller parameters to your model in one shot makes the programmer's job
easier, but this convenience also allows malicious use. What if a request to
the server was crafted to look like a new article form submit but also included
extra fields with values that violated your application's integrity? They would
be 'mass assigned' into your model and then into the database along with the
good stuff - potentially breaking your application or worse.</p>

<p>We have to define our permitted controller parameters to prevent wrongful mass
assignment. In this case, we want to both allow and require the <code>title</code> and
<code>text</code> parameters for valid use of <code>create</code>. The syntax for this introduces
<code>require</code> and <code>permit</code>. The change will involve one line in the <code>create</code>
action:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
  @article = Article.new(params.require(:article).permit(:title, :text))

</pre>
</div>
<p>This is often factored out into its own method so it can be reused by multiple
actions in the same controller, for example <code>create</code> and <code>update</code>. Above and
beyond mass assignment issues, the method is often made <code>private</code> to make sure
it can't be called outside its intended context. Here is the result:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @article = Article.new(article_params)

  @article.save
  redirect_to @article
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end

</pre>
</div>
<div class="info"><p>For more information, refer to the reference above and
<a href="https://weblog.rubyonrails.org/2012/3/21/strong-parameters/">this blog article about Strong Parameters</a>.</p></div>

<h4 id="showing-articles"><a class="anchorlink" href="#showing-articles">5.7 Showing Articles</a></h4>

<p>If you submit the form again now, Rails will complain about not finding the
<code>show</code> action. That's not very useful though, so let's add the <code>show</code> action
before proceeding.</p>

<p>As we have seen in the output of <code>rails routes</code>, the route for <code>show</code> action is
as follows:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
article GET    /articles/:id(.:format)      articles#show

</pre>
</div>
<p>The special syntax <code>:id</code> tells rails that this route expects an <code>:id</code>
parameter, which in our case will be the id of the article.</p>

<p>As we did before, we need to add the <code>show</code> action in
<code>app/controllers/articles_controller.rb</code> and its respective view.</p>

<div class="note"><p>A frequent practice is to place the standard CRUD actions in each
controller in the following order: <code>index</code>, <code>show</code>, <code>new</code>, <code>edit</code>, <code>create</code>, <code>update</code>
and <code>destroy</code>. You may use any order you choose, but keep in mind that these
are public methods; as mentioned earlier in this guide, they must be placed
before declaring <code>private</code> visibility in the controller.</p></div>

<p>Given that, let's add the <code>show</code> action, as follows:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def show
    @article = Article.find(params[:id])
  end

  def new
  end

  # snippet for brevity

</pre>
</div>
<p>A couple of things to note. We use <code>Article.find</code> to find the article we're
interested in, passing in <code>params[:id]</code> to get the <code>:id</code> parameter from the
request. We also use an instance variable (prefixed with <code>@</code>) to hold a
reference to the article object. We do this because Rails will pass all instance
variables to the view.</p>

<p>Now, create a new file <code>app/views/articles/show.html.erb</code> with the following
content:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

</pre>
</div>
<p>With this change, you should finally be able to create new articles.
Visit <a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> and give it a try!</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/show_action_for_articles.png" alt="Show action for articles"></p>

<h4 id="listing-all-articles"><a class="anchorlink" href="#listing-all-articles">5.8 Listing all articles</a></h4>

<p>We still need a way to list all our articles, so let's do that.
The route for this as per output of <code>rails routes</code> is:</p>

<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
articles GET    /articles(.:format)          articles#index

</pre>
</div>
<p>Add the corresponding <code>index</code> action for that route inside the
<code>ArticlesController</code> in the <code>app/controllers/articles_controller.rb</code> file.
When we write an <code>index</code> action, the usual practice is to place it as the
first method in the controller. Let's do it:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
  end

  # snippet for brevity

</pre>
</div>
<p>And then finally, add the view for this action, located at
<code>app/views/articles/index.html.erb</code>:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Listing Articles&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @articles.each do |article| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= article.text %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Show', article_path(article) %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;

</pre>
</div>
<p>Now if you go to <a href="http://localhost:3000/articles">http://localhost:3000/articles</a> you will see a list of all the
articles that you have created.</p>

<h4 id="adding-links"><a class="anchorlink" href="#adding-links">5.9 Adding links</a></h4>

<p>You can now create, show, and list articles. Now let's add some links to
navigate through pages.</p>

<p>Open <code>app/views/welcome/index.html.erb</code> and modify it as follows:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Hello, Rails!&lt;/h1&gt;
&lt;%= link_to 'My Blog', controller: 'articles' %&gt;

</pre>
</div>
<p>The <code>link_to</code> method is one of Rails' built-in view helpers. It creates a
hyperlink based on text to display and where to go - in this case, to the path
for articles.</p>

<p>Let's add links to the other views as well, starting with adding this
"New Article" link to <code>app/views/articles/index.html.erb</code>, placing it above the
<code>&lt;table&gt;</code> tag:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= link_to 'New article', new_article_path %&gt;

</pre>
</div>
<p>This link will allow you to bring up the form that lets you create a new article.</p>

<p>Now, add another link in <code>app/views/articles/new.html.erb</code>, underneath the
form, to go back to the <code>index</code> action:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, url: articles_path, local: true do |form| %&gt;
  ...
&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>Finally, add a link to the <code>app/views/articles/show.html.erb</code> template to
go back to the <code>index</code> action as well, so that people who are viewing a single
article can go back and view the whole list again:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;p&gt;
  &lt;strong&gt;Title:&lt;/strong&gt;
  &lt;%= @article.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;strong&gt;Text:&lt;/strong&gt;
  &lt;%= @article.text %&gt;
&lt;/p&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<div class="info"><p>If you want to link to an action in the same controller, you don't need to
specify the <code>:controller</code> option, as Rails will use the current controller by
default.</p></div>

<div class="info"><p>In development mode (which is what you're working in by default), Rails
reloads your application with every browser request, so there's no need to stop
and restart the web server when a change is made.</p></div>

<h4 id="adding-some-validation"><a class="anchorlink" href="#adding-some-validation">5.10 Adding Some Validation</a></h4>

<p>The model file, <code>app/models/article.rb</code> is about as simple as it can get:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ApplicationRecord
end

</pre>
</div>
<p>There isn't much to this file - but note that the <code>Article</code> class inherits from
<code>ApplicationRecord</code>. <code>ApplicationRecord</code> inherits from <code>ActiveRecord::Base</code>
which supplies a great deal of functionality to your Rails models for free,
including basic database CRUD (Create, Read, Update, Destroy) operations, data
validation, as well as sophisticated search support and the ability to relate
multiple models to one another.</p>

<p>Rails includes methods to help you validate the data that you send to models.
Open the <code>app/models/article.rb</code> file and edit it:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Article &lt; ApplicationRecord
  validates :title, presence: true,
                    length: { minimum: 5 }
end

</pre>
</div>
<p>These changes will ensure that all articles have a title that is at least five
characters long. Rails can validate a variety of conditions in a model,
including the presence or uniqueness of columns, their format, and the
existence of associated objects. Validations are covered in detail in <a href="active_record_validations.html">Active
Record Validations</a>.</p>

<p>With the validation now in place, when you call <code>@article.save</code> on an invalid
article, it will return <code>false</code>. If you open
<code>app/controllers/articles_controller.rb</code> again, you'll notice that we don't
check the result of calling <code>@article.save</code> inside the <code>create</code> action.
If <code>@article.save</code> fails in this situation, we need to show the form back to the
user. To do this, change the <code>new</code> and <code>create</code> actions inside
<code>app/controllers/articles_controller.rb</code> to these:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def new
  @article = Article.new
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end

</pre>
</div>
<p>The <code>new</code> action is now creating a new instance variable called <code>@article</code>, and
you'll see why that is in just a few moments.</p>

<p>Notice that inside the <code>create</code> action we use <code>render</code> instead of <code>redirect_to</code>
when <code>save</code> returns <code>false</code>. The <code>render</code> method is used so that the <code>@article</code>
object is passed back to the <code>new</code> template when it is rendered. This rendering
is done within the same request as the form submission, whereas the
<code>redirect_to</code> will tell the browser to issue another request.</p>

<p>If you reload
<a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a> and
try to save an article without a title, Rails will send you back to the
form, but that's not very useful. You need to tell the user that
something went wrong. To do that, you'll modify
<code>app/views/articles/new.html.erb</code> to check for error messages:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with scope: :article, url: articles_path, local: true do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>A few things are going on. We check if there are any errors with
<code>@article.errors.any?</code>, and in that case we show a list of all
errors with <code>@article.errors.full_messages</code>.</p>

<p><code>pluralize</code> is a rails helper that takes a number and a string as its
arguments. If the number is greater than one, the string will be automatically
pluralized.</p>

<p>The reason why we added <code>@article = Article.new</code> in the <code>ArticlesController</code> is
that otherwise <code>@article</code> would be <code>nil</code> in our view, and calling
<code>@article.errors.any?</code> would throw an error.</p>

<div class="info"><p>Rails automatically wraps fields that contain an error with a div
with class <code>field_with_errors</code>. You can define a CSS rule to make them
standout.</p></div>

<p>Now you'll get a nice error message when saving an article without a title when
you attempt to do just that on the new article form
<a href="http://localhost:3000/articles/new">http://localhost:3000/articles/new</a>:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/form_with_errors.png" alt="Form With Errors"></p>

<h4 id="updating-articles"><a class="anchorlink" href="#updating-articles">5.11 Updating Articles</a></h4>

<p>We've covered the "CR" part of CRUD. Now let's focus on the "U" part, updating
articles.</p>

<p>The first step we'll take is adding an <code>edit</code> action to the <code>ArticlesController</code>,
generally between the <code>new</code> and <code>create</code> actions, as shown:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def new
  @article = Article.new
end

def edit
  @article = Article.find(params[:id])
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

</pre>
</div>
<p>The view will contain a form similar to the one we used when creating
new articles. Create a file called <code>app/views/articles/edit.html.erb</code> and make
it look as follows:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Edit Article&lt;/h1&gt;

&lt;%= form_with(model: @article, local: true) do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>This time we point the form to the <code>update</code> action, which is not defined yet
but will be very soon.</p>

<p>Passing the article object to the <code>form_with</code> method will automatically set the URL for
submitting the edited article form. This option tells Rails that we want this
form to be submitted via the <code>PATCH</code> HTTP method, which is the HTTP method you're
expected to use to <strong>update</strong> resources according to the REST protocol.</p>

<p>Also, passing a model object to <code>form_with</code>, like <code>model: @article</code> in the edit
view above, will cause form helpers to fill in form fields with the corresponding
values of the object.  Passing in a symbol scope such as <code>scope: :article</code>, as
was done in the new view, only creates empty form fields.
More details can be found in <a href="https://api.rubyonrails.org/v6.0.6.1/classes/ActionView/Helpers/FormHelper.html#method-i-form_with">form_with documentation</a>.</p>

<p>Next, we need to create the <code>update</code> action in
<code>app/controllers/articles_controller.rb</code>.
Add it between the <code>create</code> action and the <code>private</code> method:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

def update
  @article = Article.find(params[:id])

  if @article.update(article_params)
    redirect_to @article
  else
    render 'edit'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end

</pre>
</div>
<p>The new method, <code>update</code>, is used when you want to update a record
that already exists, and it accepts a hash containing the attributes
that you want to update. As before, if there was an error updating the
article we want to show the form back to the user.</p>

<p>We reuse the <code>article_params</code> method that we defined earlier for the create
action.</p>

<div class="info"><p>It is not necessary to pass all the attributes to <code>update</code>. For example,
if <code>@article.update(title: 'A new title')</code> was called, Rails would only update
the <code>title</code> attribute, leaving all other attributes untouched.</p></div>

<p>Finally, we want to show a link to the <code>edit</code> action in the list of all the
articles, so let's add that now to <code>app/views/articles/index.html.erb</code> to make
it appear next to the "Show" link:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th colspan="2"&gt;&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @articles.each do |article| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= article.text %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Show', article_path(article) %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Edit', edit_article_path(article) %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;

</pre>
</div>
<p>And we'll also add one to the <code>app/views/articles/show.html.erb</code> template as
well, so that there's also an "Edit" link on an article's page. Add this at the
bottom of the template:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
...

&lt;%= link_to 'Edit', edit_article_path(@article) %&gt; |
&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>And here's how our app looks so far:</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/index_action_with_edit_link.png" alt="Index action with edit link"></p>

<h4 id="using-partials-to-clean-up-duplication-in-views"><a class="anchorlink" href="#using-partials-to-clean-up-duplication-in-views">5.12 Using partials to clean up duplication in views</a></h4>

<p>Our <code>edit</code> page looks very similar to the <code>new</code> page; in fact, they
both share the same code for displaying the form. Let's remove this
duplication by using a view partial. By convention, partial files are
prefixed with an underscore.</p>

<div class="info"><p>You can read more about partials in the
<a href="layouts_and_rendering.html">Layouts and Rendering in Rails</a> guide.</p></div>

<p>Create a new file <code>app/views/articles/_form.html.erb</code> with the following
content:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_with model: @article, local: true do |form| %&gt;

  &lt;% if @article.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;
        &lt;%= pluralize(@article.errors.count, "error") %&gt; prohibited
        this article from being saved:
      &lt;/h2&gt;
      &lt;ul&gt;
        &lt;% @article.errors.full_messages.each do |msg| %&gt;
          &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
        &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;p&gt;
    &lt;%= form.label :title %&gt;&lt;br&gt;
    &lt;%= form.text_field :title %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;

  &lt;p&gt;
    &lt;%= form.submit %&gt;
  &lt;/p&gt;

&lt;% end %&gt;

</pre>
</div>
<p>Everything except for the <code>form_with</code> declaration remained the same.
The reason we can use this shorter, simpler <code>form_with</code> declaration
to stand in for either of the other forms is that <code>@article</code> is a <em>resource</em>
corresponding to a full set of RESTful routes, and Rails is able to infer
which URI and method to use.
For more information about this use of <code>form_with</code>, see <a href="https://api.rubyonrails.org/v6.0.6.1/classes/ActionView/Helpers/FormHelper.html#method-i-form_with-label-Resource-oriented+style">Resource-oriented style</a>.</p>

<p>Now, let's update the <code>app/views/articles/new.html.erb</code> view to use this new
partial, rewriting it completely:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;New Article&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<p>Then do the same for the <code>app/views/articles/edit.html.erb</code> view:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Edit Article&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', articles_path %&gt;

</pre>
</div>
<h4 id="deleting-articles"><a class="anchorlink" href="#deleting-articles">5.13 Deleting Articles</a></h4>

<p>We're now ready to cover the "D" part of CRUD, deleting articles from the
database. Following the REST convention, the route for
deleting articles as per output of <code>rails routes</code> is:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
DELETE /articles/:id(.:format)      articles#destroy

</pre>
</div>
<p>The <code>delete</code> routing method should be used for routes that destroy
resources. If this was left as a typical <code>get</code> route, it could be possible for
people to craft malicious URLs like this:</p>

<div class="code_container">
<pre class="brush: xml; gutter: false; toolbar: false">
&lt;a href='http://example.com/articles/1/destroy'&gt;look at this cat!&lt;/a&gt;

</pre>
</div>
<p>We use the <code>delete</code> method for destroying resources, and this route is mapped
to the <code>destroy</code> action inside <code>app/controllers/articles_controller.rb</code>, which
doesn't exist yet. The <code>destroy</code> method is generally the last CRUD action in
the controller, and like the other public CRUD actions, it must be placed
before any <code>private</code> or <code>protected</code> methods. Let's add it:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def destroy
  @article = Article.find(params[:id])
  @article.destroy

  redirect_to articles_path
end

</pre>
</div>
<p>The complete <code>ArticlesController</code> in the
<code>app/controllers/articles_controller.rb</code> file should now look like this:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
    @article = Article.new
  end

  def edit
    @article = Article.find(params[:id])
  end

  def create
    @article = Article.new(article_params)

    if @article.save
      redirect_to @article
    else
      render 'new'
    end
  end

  def update
    @article = Article.find(params[:id])

    if @article.update(article_params)
      redirect_to @article
    else
      render 'edit'
    end
  end

  def destroy
    @article = Article.find(params[:id])
    @article.destroy

    redirect_to articles_path
  end

  private
    def article_params
      params.require(:article).permit(:title, :text)
    end
end

</pre>
</div>
<p>You can call <code>destroy</code> on Active Record objects when you want to delete
them from the database. Note that we don't need to add a view for this
action since we're redirecting to the <code>index</code> action.</p>

<p>Finally, add a 'Destroy' link to your <code>index</code> action template
(<code>app/views/articles/index.html.erb</code>) to wrap everything together.</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;h1&gt;Listing Articles&lt;/h1&gt;
&lt;%= link_to 'New article', new_article_path %&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Text&lt;/th&gt;
    &lt;th colspan="3"&gt;&lt;/th&gt;
  &lt;/tr&gt;

  &lt;% @articles.each do |article| %&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= article.text %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Show', article_path(article) %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Edit', edit_article_path(article) %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= link_to 'Destroy', article_path(article),
              method: :delete,
              data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;

</pre>
</div>
<p>Here we're using <code>link_to</code> in a different way. We pass the named route as the
second argument, and then the options as another argument. The <code>method: :delete</code>
and <code>data: { confirm: 'Are you sure?' }</code> options are used as HTML5 attributes so
that when the link is clicked, Rails will first show a confirm dialog to the
user, and then submit the link with method <code>delete</code>.  This is done via the
JavaScript file <code>rails-ujs</code> which is automatically included in your
application's layout (<code>app/views/layouts/application.html.erb</code>) when you
generated the application. Without this file, the confirmation dialog box won't
appear.</p>

<p><img src="/home/rails/v6.0.6.1/guides/output/kindle/images/getting_started/confirm_dialog.png" alt="Confirm Dialog"></p>

<div class="info"><p>Learn more about Unobtrusive JavaScript on
<a href="working_with_javascript_in_rails.html">Working With JavaScript in Rails</a> guide.</p></div>

<p>Congratulations, you can now create, show, list, update, and destroy
articles.</p>

<div class="info"><p>In general, Rails encourages using resources objects instead of
declaring routes manually. For more information about routing, see
<a href="routing.html">Rails Routing from the Outside In</a>.</p></div>
</body>
</html>

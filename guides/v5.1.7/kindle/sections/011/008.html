<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>9 Building Complex Forms</title>
<link rel="stylesheet" type="text/css" href="/home/rails/v5.1.7/guides/output/kindle/stylesheets/kindle.css">
</head>
<body>
<h3 id="building-complex-forms">9 Building Complex Forms</h3>
<p>Many apps grow beyond simple forms editing a single object. For example, when creating a <code>Person</code> you might want to allow the user to (on the same form) create multiple address records (home, work, etc.). When later editing that person the user should be able to add, remove or amend addresses as necessary.</p>

<h4 id="configuring-the-model">9.1 Configuring the Model</h4>

<p>Active Record provides model level support via the <code>accepts_nested_attributes_for</code> method:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses
end

class Address &lt; ApplicationRecord
  belongs_to :person
end

</pre>
</div>
<p>This creates an <code>addresses_attributes=</code> method on <code>Person</code> that allows you to create, update and (optionally) destroy addresses.</p>

<h4 id="nested-forms">9.2 Nested Forms</h4>

<p>The following form allows a user to create a <code>Person</code> and its associated addresses.</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @person do |f| %&gt;
  Addresses:
  &lt;ul&gt;
    &lt;%= f.fields_for :addresses do |addresses_form| %&gt;
      &lt;li&gt;
        &lt;%= addresses_form.label :kind %&gt;
        &lt;%= addresses_form.text_field :kind %&gt;

        &lt;%= addresses_form.label :street %&gt;
        &lt;%= addresses_form.text_field :street %&gt;
        ...
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;% end %&gt;

</pre>
</div>
<p>When an association accepts nested attributes <code>fields_for</code> renders its block once for every element of the association. In particular, if a person has no addresses it renders nothing. A common pattern is for the controller to build one or more empty children so that at least one set of fields is shown to the user. The example below would result in 2 sets of address fields being rendered on the new person form.</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def new
  @person = Person.new
  2.times { @person.addresses.build}
end

</pre>
</div>
<p>The <code>fields_for</code> yields a form builder. The parameters' name will be what
<code>accepts_nested_attributes_for</code> expects. For example, when creating a user with
2 addresses, the submitted parameters would look like:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
{
  'person' =&gt; {
    'name' =&gt; 'John Doe',
    'addresses_attributes' =&gt; {
      '0' =&gt; {
        'kind' =&gt; 'Home',
        'street' =&gt; '221b Baker Street'
      },
      '1' =&gt; {
        'kind' =&gt; 'Office',
        'street' =&gt; '31 Spooner Street'
      }
    }
  }
}

</pre>
</div>
<p>The keys of the <code>:addresses_attributes</code> hash are unimportant, they need merely be different for each address.</p>

<p>If the associated object is already saved, <code>fields_for</code> autogenerates a hidden input with the <code>id</code> of the saved record. You can disable this by passing <code>include_id: false</code> to <code>fields_for</code>. You may wish to do this if the autogenerated input is placed in a location where an input tag is not valid HTML or when using an ORM where children do not have an <code>id</code>.</p>

<h4 id="the-controller">9.3 The Controller</h4>

<p>As usual you need to
<a href="action_controller_overview.html#strong-parameters">whitelist the parameters</a> in
the controller before you pass them to the model:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def create
  @person = Person.new(person_params)
  # ...
end

private
  def person_params
    params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street])
  end

</pre>
</div>
<h4 id="removing-objects">9.4 Removing Objects</h4>

<p>You can allow users to delete associated objects by passing <code>allow_destroy: true</code> to <code>accepts_nested_attributes_for</code></p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, allow_destroy: true
end

</pre>
</div>
<p>If the hash of attributes for an object contains the key <code>_destroy</code> with a value
of <code>1</code> or <code>true</code> then the object will be destroyed. This form allows users to
remove addresses:</p>

<div class="code_container">
<pre class="brush: ruby; html-script: true; gutter: false; toolbar: false">
&lt;%= form_for @person do |f| %&gt;
  Addresses:
  &lt;ul&gt;
    &lt;%= f.fields_for :addresses do |addresses_form| %&gt;
      &lt;li&gt;
        &lt;%= addresses_form.check_box :_destroy%&gt;
        &lt;%= addresses_form.label :kind %&gt;
        &lt;%= addresses_form.text_field :kind %&gt;
        ...
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;/ul&gt;
&lt;% end %&gt;

</pre>
</div>
<p>Don't forget to update the whitelisted params in your controller to also include
the <code>_destroy</code> field:</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def person_params
  params.require(:person).
    permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy])
end

</pre>
</div>
<h4 id="preventing-empty-records">9.5 Preventing Empty Records</h4>

<p>It is often useful to ignore sets of fields that the user has not filled in. You can control this by passing a <code>:reject_if</code> proc to <code>accepts_nested_attributes_for</code>. This proc will be called with each hash of attributes submitted by the form. If the proc returns <code>false</code> then Active Record will not build an associated object for that hash. The example below only tries to build an address if the <code>kind</code> attribute is set.</p>

<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?}
end

</pre>
</div>
<p>As a convenience you can instead pass the symbol <code>:all_blank</code> which will create a proc that will reject records where all the attributes are blank excluding any value for <code>_destroy</code>.</p>

<h4 id="adding-fields-on-the-fly">9.6 Adding Fields on the Fly</h4>

<p>Rather than rendering multiple sets of fields ahead of time you may wish to add them only when a user clicks on an 'Add new address' button. Rails does not provide any built-in support for this. When generating new sets of fields you must ensure the key of the associated array is unique - the current JavaScript date (milliseconds after the epoch) is a common choice.</p>
</body>
</html>
